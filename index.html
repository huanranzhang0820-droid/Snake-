<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>贪吃蛇（iPhone）</title>
  <style>
    :root { font-family: system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Microsoft YaHei",sans-serif; }
    body { margin:0; background:#0b0f14; color:#e7eef8; display:flex; min-height:100vh; align-items:center; justify-content:center; }
    .wrap { width:min(520px, 94vw); }
    .topbar { display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom:10px; }
    .stats { display:flex; gap:14px; align-items:center; font-weight:700; }
    button{
      background:#1b2430; color:#e7eef8; border:1px solid #2b3a4d;
      border-radius:12px; padding:8px 12px; cursor:pointer; font-weight:700;
    }
    .card { background:#111824; border:1px solid #223044; border-radius:14px; padding:12px; }
    canvas { width:100%; height:auto; background:#0e1520; border-radius:12px; display:block; touch-action:none; }

    .controls { margin-top:12px; display:flex; gap:12px; align-items:center; justify-content:space-between; }
    .dpad { width:180px; height:180px; display:grid; grid-template-columns:repeat(3, 1fr); grid-template-rows:repeat(3,1fr); gap:8px; }
    .dpad button { padding:0; height:100%; font-size:18px; }
    .dpad .blank { opacity:0; pointer-events:none; }
    .rightcol { display:flex; flex-direction:column; gap:10px; align-items:stretch; flex:1; }
    .rightcol button { width:100%; }
    .hint { margin-top:10px; opacity:.85; font-size:14px; line-height:1.5; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="stats">
        <div>分数：<span id="score">0</span></div>
        <div>最高：<span id="best">0</span></div>
      </div>
      <div class="btns">
        <button id="btnPause">暂停</button>
        <button id="btnRestart">重开</button>
      </div>
    </div>

    <div class="card">
      <canvas id="game" width="400" height="400"></canvas>

      <div class="controls">
        <div class="dpad">
          <button class="blank"> </button>
          <button data-dir="U">↑</button>
          <button class="blank"> </button>

          <button data-dir="L">←</button>
          <button id="btnAction">开始</button>
          <button data-dir="R">→</button>

          <button class="blank"> </button>
          <button data-dir="D">↓</button>
          <button class="blank"> </button>
        </div>

        <div class="rightcol">
          <button id="btnSpeed">速度：普通</button>
          <button id="btnGrid">网格：20×20</button>
        </div>
      </div>

      <div class="hint">
        iPhone：点方向键或在画布上<strong>滑动</strong>控制。<br/>
        食物是小爱心 ❤️。吃到加分，撞墙或撞到自己结束。
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');
  const btnAction = document.getElementById('btnAction');
  const btnSpeed = document.getElementById('btnSpeed');
  const btnGrid = document.getElementById('btnGrid');

  let gridSize = 20;
  let cell = canvas.width / gridSize;

  const speeds = [
    {name:'慢',   ms:140},
    {name:'普通', ms:95},
    {name:'快',   ms:70},
    {name:'地狱', ms:50},
  ];
  let speedIndex = 1;

  let snake, dir, nextDir, food, score, best, running, paused, timer;

  best = Number(localStorage.getItem('snake_best') || 0);
  bestEl.textContent = best;

  function randCell() {
    return { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
  }

  function placeFood() {
    while (true) {
      const p = randCell();
      const hit = snake.some(s => s.x === p.x && s.y === p.y);
      if (!hit) return p;
    }
  }

  function reset() {
    snake = [{x: Math.floor(gridSize/2), y: Math.floor(gridSize/2)}];
    dir = {x:1, y:0};
    nextDir = dir;
    food = placeFood();
    score = 0;
    running = false;
    paused = false;
    clearInterval(timer);
    timer = null;
    scoreEl.textContent = score;
    btnAction.textContent = '开始';
    btnPause.textContent = '暂停';
    draw();
  }

  function start() {
    if (running) return;
    running = true;
    paused = false;
    btnAction.textContent = '进行中';
    loop();
  }

  function loop() {
    clearInterval(timer);
    timer = setInterval(() => {
      if (!running || paused) return;
      step();
      draw();
    }, speeds[speedIndex].ms);
  }

  function gameOver() {
    running = false;
    paused = false;
    clearInterval(timer);
    timer = null;
    btnAction.textContent = '开始';
    alert('游戏结束！分数：' + score);
  }

  function step() {
    dir = nextDir;

    const head = snake[0];
    const nx = head.x + dir.x;
    const ny = head.y + dir.y;

    if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) {
      syncBest();
      return gameOver();
    }

    if (snake.some((s, i) => i !== 0 && s.x === nx && s.y === ny)) {
      syncBest();
      return gameOver();
    }

    snake.unshift({x:nx, y:ny});

    if (nx === food.x && ny === food.y) {
      score += 10;
      scoreEl.textContent = score;
      food = placeFood();
    } else {
      snake.pop();
    }
  }

  function syncBest() {
    if (score > best) {
      best = score;
      localStorage.setItem('snake_best', String(best));
      bestEl.textContent = best;
    }
  }

  function drawGrid() {
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    for (let i=1;i<gridSize;i++){
      ctx.beginPath();
      ctx.moveTo(i*cell,0); ctx.lineTo(i*cell,canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,i*cell); ctx.lineTo(canvas.width,i*cell);
      ctx.stroke();
    }
  }

  function roundRect(x, y, w, h, r, fill) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
    if (fill) ctx.fill();
  }

  function drawHeart(cellX, cellY) {
    // 用 emoji 绘制小爱心：简单、无需图片
    const cx = cellX*cell + cell/2;
    const cy = cellY*cell + cell/2;
    ctx.font = `bold ${Math.floor(cell*0.78)}px system-ui, Apple Color Emoji`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('❤️', cx, cy+1);
  }

  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();

    // 食物：小爱心
    drawHeart(food.x, food.y);

    // 蛇
    snake.forEach((s, i) => {
      ctx.fillStyle = i===0 ? '#7cf2c4' : '#42c7ff';
      roundRect(s.x*cell+2, s.y*cell+2, cell-4, cell-4, 6, true);
    });

    if (paused) {
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 24px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('已暂停', canvas.width/2, canvas.height/2);
    }

    if (!running) {
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('点“开始”或滑动/点方向键开始', canvas.width/2, canvas.height/2);
    }
  }

  function setDir(dx, dy) {
    if (dx === -dir.x && dy === -dir.y) return;
    nextDir = {x:dx, y:dy};
    if (!running) start();
  }

  // 屏幕方向键
  document.querySelectorAll('[data-dir]').forEach(btn => {
    btn.addEventListener('click', () => {
      const d = btn.dataset.dir;
      if (d==='U') setDir(0,-1);
      if (d==='D') setDir(0,1);
      if (d==='L') setDir(-1,0);
      if (d==='R') setDir(1,0);
    });
  });

  // 触摸滑动
  let touchStart = null;
  canvas.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    touchStart = {x: t.clientX, y: t.clientY};
  }, {passive:true});

  canvas.addEventListener('touchend', (e) => {
    if (!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const absX = Math.abs(dx), absY = Math.abs(dy);
    const threshold = 18;
    if (absX < threshold && absY < threshold) return;
    if (absX > absY) setDir(dx>0 ? 1: -1, 0);
    else setDir(0, dy>0 ? 1: -1);
    touchStart = null;
  }, {passive:true});

  function togglePause() {
    if (!running) return;
    paused = !paused;
    btnPause.textContent = paused ? '继续' : '暂停';
    draw();
  }

  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', () => { syncBest(); reset(); });
  btnAction.addEventListener('click', () => { if (!running) start(); });

  btnSpeed.addEventListener('click', () => {
    speedIndex = (speedIndex + 1) % speeds.length;
    btnSpeed.textContent = '速度：' + speeds[speedIndex].name;
    if (running) {
      // 重新设定速度
      clearInterval(timer);
      loop();
    }
  });

  btnGrid.addEventListener('click', () => {
    gridSize = (gridSize === 20) ? 25 : (gridSize === 25 ? 16 : 20);
    btnGrid.textContent = '网格：' + gridSize + '×' + gridSize;
    cell = canvas.width / gridSize;
    syncBest();
    reset();
  });

  reset();
})();
</script>
</body>
</html>
